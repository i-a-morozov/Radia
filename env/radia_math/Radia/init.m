(* ::Package:: *)

(* Modified by I.M., 2025 *)
(* Added RadFldPtcTrj with API matching radFldPtcTrj *)
(* Uses NDSolve for integration allowing integration method specification *)
(* Tracking utilities, transport matrix generation, drift-kick-drift tracking with kick maps *)
(* Added utilities for tracking from RadiaToTrack.nb *)

$RadVersion=4.32  (* March 2017 *)

(*___ ___ ___ ___ ___ _   Copyright Notice   ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ _

Radia is copyright European Synchrotron Radiation Facility.
Portions copyright Synchrotron SOLEIL.
Portions copyright Wolfram Research, Inc.

 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
 "Software"), to use, copy, modify, and distribute the Software without
 restriction, provided the Software, including any modified copies made
 under this license, is not distributed for a fee, subject to
 the following conditions:
 
 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.
  
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE EUROPEAN SYNCHROTRON RADIATION FACILITY BE LIABLE
 FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 ______ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___*)
 
  (***********************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which typically
will have the same name as this file except ending in ".nb" instead of
".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent to
using the Evaluate Initialization Cells menu command in the front end.

DO NOT EDIT THIS FILE.  This entire file is regenerated automatically 
each time the parent Notebook file is saved in the Mathematica front end.
Any changes you make to this file will be overwritten.
***********************************************************************)


(* --------- Usages ----------------------- *)

RadLinkPattern::usage="RadLinkPattern[] gives the Link patterns of a routine in Radia.exe"

RadMatNdFeB::usage="RadMatNdFeB[Mr:1.2] creates a NdFeB magnetic material with remanent magnetization Mr. The direction of the remanent magnetization vector is defined by the initial magnetization vector in the object to which the material is later applied." 

RadMatSmCo5::usage="RadMatSmCo5[Mr:0.85] creates a SmCo5 magnetic material with remanent magnetization Mr. The direction of the remanent magnetization vector is defined by the initial magnetization vector in the object to which the material is later applied." 

RadMatSm2Co17::usage="RadMatSm2Co17[Mr:1.05] creates a Sm2Co17 magnetic material with remanent magnetization Mr. The direction of the remanent magnetization vector is defined by the initial magnetization vector in the object to which the material is later applied." 

RadMatFerrite::usage="RadMatFerrite[Mr:0.35] creates a Ferrite magnetic material with remanent magnetization Mr. The direction of the remanent magnetization vector is defined by the initial magnetization vector in the object to which the material is later applied." 

RadMatXc06::usage="RadMatXc06[] creates an inexpensive Low Carbon Steel with C<0.06% [AFNOR]."

RadMatSteel37::usage="RadMatSteel37[] creates an inexpensive Steel with C<0.13%."
 
RadMatSteel42::usage="RadMatSteel42[] creates an inexpensive Steel with C<0.19%."
 
RadMatAFK502::usage="RadMatAFK502[] creates a Vanadium Permendur type material from MetalImphy (Fe : 49%, Co: 49%, V: 2%) similar to Vacoflux50 from VacuumSchmelze."

RadMatAFK1::usage="RadMatAFK1[] creates an inexpensive FeCo Alloy from MetalImphy (Fe : 74.2, Co: 25%, Cr: 0.3%, Mn: 0.5%)."

RadTrfZerPara::usage="RadTrfZerPara[Obj,{Ptx,Pty,Ptz},{Vx,Vy,Vz}] creates an Object Mirror of Obj with respect to the plane with normal {Vx,Vy,Vz} and passing by the point {Ptx,Pty,Ptz}. The Object Mirror presents the same geometry as Obj, but its magnetization and/or current densities are modified in such a way that the magnetic field produced by the Obj and its Mirror in the plane of mirroring is perpendicular to this plane."

RadTrfZerPerp::usage="RadTrfZerPerp[Obj,{Ptx,Pty,Ptz},{Vx,Vy,Vz}] creates an Object Mirror of Obj with respect to the plane with normal {Vx,Vy,Vz} and passing by the point {Ptx,Pty,Ptz}. The Object Mirror presents the same geometry as Obj, but its magnetization and/or current densities are modified in such a way that the magnetic field produced by the Obj and its Mirror in the plane of mirroring is parallel to this plane."

RadTrfAxisPerm::usage="RadTrfAxisPerm[n] creates a space transformation corresponding to the combination of n successive circular permutations of the x,y and z axes."

RadObjFullMag::usage="RadObjFullMag[{Ptx,Pty,Ptz},{Wx,Wy,Wz},{Mx,My,Mz},{Kx,Ky,Kz},ObjCont,Mat,{R,G,B}] creates a parallellepipedic block with center point {Ptx,Pty,Ptz}, dimensions {Wx,Wy,Wz} and color {R,G,B}. The block is magnetized according to {Mx,My,Mz} then subdivided according to {Kx,Ky,Kz} and added into the container ObjCont. ObjCont should be defined in advance by calling radObjCnt[]."

RadSolve::usage="RadSolve[Obj,Prec,MaxIter,Method:0] builds an interaction matrix for the object Obj and performs a relaxation procedure. The relaxation stops whenever the change of magnetization (averaged over all sub-elements) between two successive iterations is smaller than Prec or the number of iterations is larger than MaxIter. The interaction matrix is deleted. Method is an integer number specifying the method of relaxation to be used, values between 3 and 5 must be used. If no value is entered, a default method is automatically selected."

RadUtiSave::usage="RadUtiSave[Elem,FilePath] saves internal representation data of Elem (that can be a Radia 3D object, transformation, material, etc., or a list of those) to a binary file; FilePath is a full path with a name of this file to be created."

RadUtiLoad::usage="RadUtiLoad[FilePath] loads internal representation data of an element or a list of elements (that can be Radia 3D objects, transformations, materials, etc.) from a binary file with the full path FilePath, previously created by RadUtiSave[Elem,FilePath] function; return index (or list of indexes) of elements loaded."

RadUtiMem::usage="RadUtiMem[] saves some memory in the Mathematica Kernel"   

RadUtiVer::usage="RadUtiVer[] returns the Radia version number."

RadPlotOptions::usage="RadPlotOptions[] sets Default Options for the Plot function."

RadPlot3DOptions::usage="RadPlot3DOptions[] sets Default Options for the Graphics3D and Plot3D functions."

RadObjExtRtg::usage="RadObjExtRtg[{{x1,y1,z1},{Wx1,Wy1}},{{x2,y2,z2},{Wx2,Wy2}},{Mx,My,Mz}:{0,0,0}] creates a magnetized polyhedron volume bound by six faces. Two faces are rectangles parallel to each other and perpendicular to the z direction. The rectangles 1 and 2 are defined by their centers of gravity {x1,y1,z1}, {x2,y2,z2} and dimensions in x and y directions {Wx1,Wy1}, {Wx2,Wy2}. The other 4 faces are trapezoids and connect the sides of the rectangle 1 and 2 which are parallel to each other. {Mx,My,Mz} is the magnetization."


(* --------- Plot Options --------- *)

ListQ3[w_]:=VectorQ[w, NumberQ] && If[Dimensions[w]=={3},True,False]

RadPlotOptions[]:=(
$DefaultFont={"Times",12};
SetOptions[{ListPlot,Plot}
,AxesStyle->Thickness[0.001]    
,PlotStyle->Thickness[0.002]  	
,Axes->True
,Frame->True
,GridLines->Automatic
,RotateLabel->False
,PlotRange->All];
);

RadPlot3DOptions[]:=(
$DefaultFont={"Times",12};
SetOptions[Graphics3D
,Axes->True
,AxesLabel->{"X ","Y ","Z "}
,AxesStyle->Thickness[0.003]
,BoxStyle->{Thickness[0.001],Dashing[{0.01,0.01}]}
,PlotRange->All
,SphericalRegion->True
,ViewPoint->{3.5, -2, 1.5}]);


(* --------- General Use --------- *)

RadLinkPattern[]:=LinkPatterns[Radlk]


(* --------- Magnetic Materials --------- *)

RadMatNdFeB[{Mx_,My_,Mz_},Mr_:1.2]:=
Module[{r},
r=Mr/Sqrt[Mx^2+My^2+Mz^2];
radMatLin[{0.06,0.17},{r*Mx,r*My,r*Mz}]]/;
NumberQ[Mx] /; NumberQ[My] /; NumberQ[Mz] /; NumberQ[Mr]

RadMatNdFeB[Mr_:1.2]:= radMatLin[{0.06,0.17},Mr]/; NumberQ[Mr]

RadMatSmCo5[{Mx_,My_,Mz_},Mr_:0.85]:=
Module[{r},
r=Mr/Sqrt[Mx^2+My^2+Mz^2];
radMatLin[{0.005,0.04},{r*Mx,r*My,r*Mz}]]/;
NumberQ[Mx] /; NumberQ[My] /; NumberQ[Mz] /; NumberQ[Mr]

RadMatSmCo5[Mr_:0.85]:= radMatLin[{0.005,0.04},Mr]/; NumberQ[Mr]

RadMatSm2Co17[{Mx_,My_,Mz_},Mr_:1.05]:=
Module[{r},
r=Mr/Sqrt[Mx^2+My^2+Mz^2];
radMatLin[{0.005,0.04},{r*Mx,r*My,r*Mz}]]/;
NumberQ[Mx] /; NumberQ[My] /; NumberQ[Mz] /; NumberQ[Mr]

RadMatSm2Co17[Mr_:1.05]:= radMatLin[{0.005,0.04},Mr]/; NumberQ[Mr]

RadMatFerrite[{Mx_,My_,Mz_},Mr_:0.35]:=
Module[{r},
r=Mr/Sqrt[Mx^2+My^2+Mz^2];
radMatLin[{0.07,0.2},{r*Mx,r*My,r*Mz}]]/;
NumberQ[Mx] /; NumberQ[My] /; NumberQ[Mz] /; NumberQ[Mr]

RadMatFerrite[Mr_:0.35]:= radMatLin[{0.07,0.2},Mr]/; NumberQ[Mr]


(* --------- Steels --------- *)

RadMatXc06[] := radMatSatIso[{1.362,0.2605,0.4917},{2118.,63.06,17.138}];

RadMatSteel37[] := radMatSatIso[{1.1488,0.4268,0.4759},{1596.3,133.11,18.713}];

RadMatSteel42[] := radMatSatIso[{1.441,0.2912,0.3316},{968.66,24.65,8.3}];

RadMatAFK502[] := radMatSatIso[{1.788,0.437,0.115},{10485.,241.5,7.43}];

RadMatAFK1[] := radMatSatIso[{1.704,0.493,0.152},{2001.,38.56,1.24}];


(* --------- Boundary Conditions --------- *)

RadTrfZerPara[Grpp_Integer,pt_List,dir_List]:=Module[{tr},
tr=radTrfPlSym[pt,dir];
radTrfCmbL[tr,radTrfInv[]];
radTrfMlt[Grpp,tr,2]
]/; ListQ3[pt] /;ListQ3[dir]

RadTrfZerPerp[obj_Integer,pt_,dir_]:=
radTrfMlt[obj,radTrfPlSym[pt,dir],2] /;
 ListQ3[pt] /; ListQ3[dir]

RadTrfAxisPerm[n_Integer]:=Module[{Pt,r1,r2,r0,i},
Pt={0,0,0};
r1=radTrfRot[Pt,{1,0,0},-N[Pi/2]];
r2=radTrfRot[Pt,{0,1,0},-N[Pi/2]];
radTrfCmbL[r1,r2];
r0=radTrfRot[Pt,{0,0,1},0];
For[i=1,i<=n,i++,radTrfCmbL[r0,r1]];
r0];


(* --------- Shapes --------- *)

RadObjExtRtg[{p1_List,{wx1_,wy1_}},{p2_List,{wx2_,wy2_}},m_List:{0,0,0}]:=
  Module[{x1,x2,y1,y2,z1,z2,v1,v2,v3,v4,v5,v6,v7,v8,f1,f2,f3,f4,f5,f6},
	x1=p1[[1]];y1=p1[[2]];z1=p1[[3]];
	x2=p2[[1]];y2=p2[[2]];z2=p2[[3]];
	v1={x1-wx1/2,y1-wy1/2,z1};
	v2={x1-wx1/2,y1+wy1/2,z1};
	v3={x1+wx1/2,y1+wy1/2,z1};
	v4={x1+wx1/2,y1-wy1/2,z1};
	v5={x2-wx2/2,y2-wy2/2,z2};
	v6={x2-wx2/2,y2+wy2/2,z2};
	v7={x2+wx2/2,y2+wy2/2,z2};
	v8={x2+wx2/2,y2-wy2/2,z2};
	f1={1,2,3,4};
	f2={5,6,7,8};
	f3={1,2,6,5};
	f4={2,3,7,6};
	f5={3,4,8,7};
	f6={4,1,5,8};
	radObjPolyhdr[{v1,v2,v3,v4,v5,v6,v7,v8},{f1,f2,f3,f4,f5,f6},m]
]/;ListQ3[p1]/;NumberQ[wx1]/;NumberQ[wy1]/;ListQ3[p2]/;NumberQ[wx2]/;NumberQ[wy2]/;ListQ3[m]


(* --------- Utility Functions --------- *)

RadObjFullMag[p_List,w_List,m_List,n_List,Grpp_Integer,Mat_Integer,c_List]:=
Module[{Ma},
Ma=radObjRecMag[p,w,m];
radMatApl[Ma,Mat];
radObjDrwAtr[Ma,c,0.001];
radObjDivMag[Ma,n];
radObjAddToCnt[Grpp,{Ma}];
Ma]/;ListQ3[p]/;ListQ3[w]/;ListQ3[m]/;ListQ3[c]

RadSolve[Obj_Integer,Prec_?NumberQ,MaxIterNum_?NumberQ,Method_Integer:0]:=
Module[{inter,rel},
inter= radRlxPre[Obj];
If[Method==0,rel=radRlxAuto[inter,Prec,MaxIterNum],
rel=radRlxAuto[inter,Prec,MaxIterNum,Method]];
radUtiDel[inter];
rel
];

RadUtiSave[elem_,fname_String]:=
Module[{dmp,file},
(*elem can be index of one elememnt or a list of indexes*)
dmp=radUtiDmp[elem,"bin"];
file=OpenWrite[fname,BinaryFormat -> True];
BinaryWrite[file,dmp];
Close[file];
elem
];

RadUtiLoad[fname_String]:=
Module[{dmp,file},
file=OpenRead[fname,BinaryFormat -> True];
dmp=Import[file,"String"]; (*BinaryRead[file];*)
Close[file];
(*can return either index of one element, or a list of indexes, or 0*)
radUtiDmpPrs[dmp]
];

(* --------- Part of RadiaToTrack.nb --------- *)

harm[gg_,typ_,per_,pos_,n_:1]:=Module[
	{c,s,t},
	nn=19*n;
	t=radFldLst[gg,typ,pos-{0,per/2,0},pos+{0,per/2,0},nn];
	t[[nn]] /=2;t[[1]] /=2;
	c=Table[Cos[n*2*\[Pi]*(i-1)/(nn-1)],{i,1,nn}];
	s=Table[Sin[n*2*\[Pi]*(i-1)/(nn-1)],{i,1,nn}];
	c=Apply[Plus,c*t]*2/(nn-1);
	s=Apply[Plus,s*t]*2/(nn-1);
	{Sqrt[c*c+s*s],ArcTan[s/c]}
];

brms[gg_,typ_,per_,pos_,n_:1]:=Module[
	{s,t},
	nn=Round[9*n];
	t=radFldLst[gg,typ,pos-{0,per/2,0},pos+{0,per/2,0},nn];
	t=t*t;
	t[[nn]] /=2;t[[1]] /=2;
	s=Sqrt[Apply[Plus,t]/(nn-1)]
];

(* return the fundamental in keV  *)
fund[gg_,p_,per_,ener_]:=Module[
	{bx,bz},
	bz=harm[gg,"bz",per,{0,0,0},1][[1]];
	bx=harm[gg,"bx",per,{0,0,0},1][[1]];
	9.5*ener*ener/per/(1+0.5*(0.0934*per*bz)^2+0.5*(0.0934*per*bx)^2)
];

(* en T2mm3  *)
pot[gg_,{x_,z_},per_,len_,prec_:1]:=Module[
	{tx,tz},
	tz=harm[gg,"bz",per,{x,0,z},1][[1]];
	tx=harm[gg,"bx",per,{x,0,z},1][[1]];
	0.5*(tx*tx+tz*tz)*len*(per/2/Pi)^2
];

(* ener in GeV per and len in millimeter angx, angz and in micro-rad  vx , vz in meter-1  *)

(* ener in GeV per and len in millimeter 
 angx,angz and in micro-rad 
vx , vz in meter-1  *)

angx[gg_,{x_,z_},per_,len_,ener_,prec_:1]:= Module[
	{p1,p2,h},
	h=0.2;
	p1=pot[gg,{x-h/2,z},per,len,prec];
	p2=pot[gg,{x+h/2,z},per,len,prec];
	(p2-p1)/h*0.5*(0.2998/ener)^2
] ;

angz[gg_,{x_,z_},per_,len_,ener_,prec_:1]:= Module[
	{p1,p2,h},
	h=0.2;
	p1=pot[gg,{x,z-h/2},per,len,prec];
	p2=pot[gg,{x,z+h/2},per,len,prec];
	(p2-p1)/h*0.5*(0.2998/ener)^2
];

vx[gg_,{x_,z_},per_,len_,ener_,prec_:1]:= Module[
	{p1,p2,p3,h},
	h=0.2;
	p1=pot[gg,{x-h/2,z},per,len,prec];
	p2=pot[gg,{x,z},per,len,prec];
	p3=pot[gg,{x+h/2,z},per,len,prec];
	4*(p1+p3-2*p2)/h^2*0.5*(0.2998/ener)^2
] ;

vz[gg_,{x_,z_},per_,len_,ener_,prec_:1]:= Module[
	{p1,p2,p3,h},
	h=0.2;
	p1=pot[gg,{x,z-h/2},per,len,prec];
	p2=pot[gg,{x,z},per,len,prec];
	p3=pot[gg,{x,z+h/2},per,len,prec];
	4*(p1+p3-2*p2)/h^2*0.5*(0.2998/ener)^2
] ;

(* --------- RadFldPtcTrj --------- *)

ClearAll[RadFldPtcTrj] ;
Options[RadFldPtcTrj] = {
	Method -> {"FixedStep", Method -> {"StiffnessSwitching",Method -> {"ExplicitRungeKutta", Automatic}}}
} ;
RadFldPtcTrj::usage="RadFldPtcTrj[obj, E, {x0, dxdy0, z0, dzdy0}, {y0, y1}, np] computes transverse coordinates and its derivatives (angles) of a relativistic charged particle trajectory in 3D magnetic field produced by the object obj, using the NDSolve interface (see default options). The particle energy is E [GeV], initial transverse coordinates and derivatives are {x0,dxdy0,z0,dzdy0}; the longitudinal coordinate y is varied from y0 to y1 in np steps. All positions are in millimeters and angles in radians." ;
RadFldPtcTrj[obj_, E_, {x0_, dxdy0_, z0_, dzdy0_}, {y0_, y1_}, np_, options:OptionsPattern[]] := Block[
	{alpha, bx, by, bz, system, x, xp, z, zp, xi, xpi, zi, zpi, y, solver, table, functions, positions},
	alpha = (0.299792458/E)/1000.0 ;
	bx[x_?NumericQ, y_?NumericQ, z_?NumericQ] := bx[x, y, z] = radFld[obj, "bx", {x, y, z}] ;
	by[x_?NumericQ, y_?NumericQ, z_?NumericQ] := by[x, y, z] = radFld[obj, "by", {x, y, z}] ;
	bz[x_?NumericQ, y_?NumericQ, z_?NumericQ] := bz[x, y, z] = radFld[obj, "bz", {x, y, z}] ;
	system = {
		x'[y] == xp[y],
		z'[y] == zp[y],
		xp'[y] == -alpha/Sqrt[1 + xp[y]^2 + zp[y]^2]*(zp[y]*by[x[y], y, z[y]] + (1 + xp[y]^2)*bz[x[y], y, z[y]] + xp[y]*zp[y]*bx[x[y], y, z[y]]),
		zp'[y] == +alpha/Sqrt[1 + xp[y]^2 + zp[y]^2]*(xp[y]*by[x[y], y, z[y]] + (1 + zp[y]^2)*bx[x[y], y, z[y]] + xp[y]*zp[y]*bz[x[y], y, z[y]]),
		x[y0] == xi,
		xp[y0] == xpi,
		z[y0] == zi,
		zp[y0] == zpi
	} ;
	solver = ParametricNDSolveValue[
		system,
		{x, xp, z, zp},
		{y, y0, y1},
		{xi, xpi, zi, zpi},
		Method -> OptionValue[Method],
		StartingStepSize -> (y1 - y0)/np,
		MaxStepSize  -> (y1 - y0)/np
	] ;
	functions = solver[x0, dxdy0, z0, dzdy0] ;
	positions = Subdivide[y0, y1, np - 1] ;
	Map[Flatten, Transpose[{positions, Map[Function[{position}, Through[functions[position]]], positions]}]]
] ;

(* --------- RadFldPtcTrjCnn --------- *)

ClearAll[RadFldPtcTrjCnn];
Options[RadFldPtcTrjCnn] = {
	"Delta" -> {0.1, 0.1},
	Method -> {"FixedStep", Method -> {"StiffnessSwitching",Method -> {"ExplicitRungeKutta", Automatic}}},
} ;
RadFldPtcTrjCnn::usage="RadFldPtcTrjCnn[obj, E, dE, {qx0, px0, qz0, pz0}, {y0, y1}, np] computes transverse canonical coordinates of a relativistic charged particle trajectory in 3D magnetic field produced by the object obj, using the NDSolve interface (see default options). The particle energy is E [GeV], initial transverse canonical coordinates are {qx0, px0, qz0, pz0}; the longitudinal coordinate y is varied from y0 to y1 in np steps. All positions are in millimeters." ;
RadFldPtcTrjCnn[obj_, E_, dE_, {qx0_, px0_, qz0_, pz0_}, {y0_, y1_}, np_, options : OptionsPattern[]] := Block[
	{alpha, Ax, Ay, Az, ax, ay, az, daxdx, daydx, dazdx, daxdz, daydz, dazdz, hx, hz, flow, system, y, qx, qz, px, pz, qxi, qzi, pxi, pzi, solver, functions, positions},
	alpha = -(0.299792458/E)/1000.0 ;
	Ax[x_?NumericQ, y_?NumericQ, z_?NumericQ] := Ax[x, y, z] = radFld[obj, "ax", {x, y, z}] ;
	Ay[x_?NumericQ, y_?NumericQ, z_?NumericQ] := Ay[x, y, z] = radFld[obj, "ay", {x, y, z}] ;
	Az[x_?NumericQ, y_?NumericQ, z_?NumericQ] := Az[x, y, z] = radFld[obj, "az", {x, y, z}] ;
	ax[x_?NumericQ, y_?NumericQ, z_?NumericQ] := alpha*Ax[x, y, z] ;
	ay[x_?NumericQ, y_?NumericQ, z_?NumericQ] := alpha*Ay[x, y, z] ;
	az[x_?NumericQ, y_?NumericQ, z_?NumericQ] := alpha*Az[x, y, z] ;
	daxdx[x_?NumericQ, y_?NumericQ, z_?NumericQ] := daxdx[x, y, z] = (ax[x + hx, y, z] - ax[x - hx, y, z])/(2 hx) ;
	daydx[x_?NumericQ, y_?NumericQ, z_?NumericQ] := daydx[x, y, z] = (ay[x + hx, y, z] - ay[x - hx, y, z])/(2 hx) ;
	dazdx[x_?NumericQ, y_?NumericQ, z_?NumericQ] := dazdx[x, y, z] = (az[x + hx, y, z] - az[x - hx, y, z])/(2 hx) ;
	daxdz[x_?NumericQ, y_?NumericQ, z_?NumericQ] := daxdz[x, y, z] = (ax[x, y, z + hz] - ax[x, y, z - hz])/(2 hz) ;
	daydz[x_?NumericQ, y_?NumericQ, z_?NumericQ] := daydz[x, y, z] = (ay[x, y, z + hz] - ay[x, y, z - hz])/(2 hz) ;
	dazdz[x_?NumericQ, y_?NumericQ, z_?NumericQ] := dazdz[x, y, z] = (az[x, y, z + hz] - az[x, y, z - hz])/(2 hz) ;
	{hx, hz} = OptionValue["Delta"] ;
	flow[qx_, qz_, px_, pz_, y_] := flow[qx, qz, px, pz, y] = Block[
		{axi, ayi, azi, pix, piz, sqrt, daxdxi, daydxi, dazdxi, daxdzi, daydzi, dazdzi, qxdot, qzdot, pxdot, pzdot},
		axi = ax[qx, y, qz] ;
		ayi = ay[qx, y, qz] ;
		azi = az[qx, y, qz] ;
		pix = px - axi ;
		piz = pz - azi ;
		sqrt = Sqrt[(1 + dE)^2 - pix^2 - piz^2] ;
		daxdxi = daxdx[qx, y, qz] ;
		daydxi = daydx[qx, y, qz] ;
		dazdxi = dazdx[qx, y, qz] ;
		daxdzi = daxdz[qx, y, qz] ;
		daydzi = daydz[qx, y, qz] ;
		dazdzi = dazdz[qx, y, qz] ;
		qxdot = pix/sqrt ;
		qzdot = piz/sqrt ;
		pxdot = daydxi + (pix*daxdxi + piz*dazdxi)/sqrt ;
		pzdot = daydzi + (pix*daxdzi + piz*dazdzi)/sqrt ;
		{qxdot, qzdot, pxdot, pzdot}
	] ;
	system = {
		{qx'[y], qz'[y], px'[y], pz'[y]} == flow[qx[y], qz[y], px[y], pz[y], y],
		qx[y0] == qxi,
		px[y0] == pxi,
		qz[y0] == qzi,
		pz[y0] == pzi
	} ;
	solver = ParametricNDSolveValue[
		system,
		{qx, px, qz, pz},
		{y, y0, y1},
		{qxi, pxi, qzi, pzi},
		Method -> OptionValue[Method],
		StartingStepSize -> (y1 - y0)/np,
		MaxStepSize -> (y1 - y0)/np
	] ;
	functions = solver[qx0, px0, qz0, pz0] ;
	positions = Subdivide[y0, y1, np - 1] ;
	Map[Flatten, Transpose[{positions, Map[Function[{position}, Through[functions[position]]], positions]}]]
] ;

(* --------- Canonical tracking utilities --------- *)

ClearAll[transport] ;
transport::usage = "transport[object, energy, delta, {start, stop}, steps, solver][{qx, px, qz, pz}] -- track canonical initial condition (x, z in meters) through slope-based solver " ;
transport[object_, energy_, delta_, {start_, stop_}, steps_, solver_:radFldPtcTrj, options:OptionsPattern[]][state_] := Block[
    {X, XP, Z, ZP},
    {X, XP, Z, ZP} = {{1, 0, 0, 0}, {0, 1/(1 + delta), 0, 0}, {0, 0, 1, 0}, {0, 0, 0, 1/(1 + delta)}} . state ;
    {X, XP, Z, ZP} = {1000.0*X, XP, 1000.0*Z, ZP} ;
    {X, XP, Z, ZP} = Rest[Last[solver[object, energy*(1 + delta), {X, XP, Z, ZP}, {start, stop}, steps, options]]] ;
    {{1, 0, 0, 0}, {0, 1 + delta, 0, 0}, {0, 0, 1, 0}, {0, 0, 0, 1 + delta}} . {X/1000.0, XP, Z/1000.0, ZP}
] ;

ClearAll[track] ;
track::usage = "track[object, energy, delta, period, count][{qx, px, qz, pz}] -- drift-kick-drift kick map canonical tracking (period in mm, x and z in m)" ;
track[object_, energy_, delta_, period_, count_][state_] := Block[
	{X, XP, Z, ZP},
	{X, XP, Z, ZP} = {{1, 0, 0, 0}, {0, 1/(1 + delta), 0, 0}, {0, 0, 1, 0}, {0, 0, 0, 1/(1 + delta)}} . state  ;
	Do[
		{X, XP, Z, ZP} = {{1, (1 + delta)*period/2/1000.0, 0, 0}, {0, 1, 0, 0}, {0, 0, 1, (1 + delta)*period/2/1000.0}, {0, 0, 0, 1}} . {X, XP, Z, ZP} ;
		{X, XP, Z, ZP} = {
			X,
			XP - angx[object, 10.0^3*{X, Z}, period, period, energy*(1 + delta)]*10^-6, 
			Z,
			ZP - angz[object, 10.0^3*{X, Z}, period, period, energy*(1 + delta)]*10^-6
		} ;
		{X, XP, Z, ZP} = {{1, (1 + delta)*period/2/1000.0, 0, 0}, {0, 1, 0, 0}, {0, 0, 1, (1 + delta)*period/2/1000.0}, {0, 0, 0, 1}} . {X, XP, Z, ZP} ;
		, count
	] ;
	{{1, 0, 0, 0}, {0, 1 + delta, 0, 0}, {0, 0, 1, 0}, {0, 0, 0, 1 + delta}} . {X, XP, Z, ZP}
] ;

(* --------- Transport matrix generation --------- *)

ClearAll[identity] ;
identity[dimension_] := KroneckerProduct[IdentityMatrix[dimension], {{0, 1}, {-1, 0}}] ;

ClearAll[symplectify] ;
symplectify::usage = "symplectify[matrix] -- symplectify given matrix (symplectic projection)" ;
symplectify[matrix_] := Block[
  {size, dimension, E, S, V, W},
  size = Length[matrix] ;
  dimension = 1/2*size ;
  E = IdentityMatrix[size] ;
  S = identity[dimension] ;
  V = S.(E - matrix).LinearSolve[E + matrix, E] ;
  W = 1/2*(V + Transpose[V]) ;
  LinearSolve[S + W, S - W]
] ;

ClearAll[matrix] ;
matrix::usage = "matrix[object, energy, delta, {start, stop}, steps, epsilon, solver] -- compute transport matrix (x and z in meters)" ;
matrix[object_, energy_, delta_, {start_, stop_}, steps_, orbit_, epsilon_, solver_:radFldPtcTrj, options:OptionsPattern[]] := Block[
	{initial, positive, negative},
	positive = transport[object, energy, delta, {start, stop}, steps, solver, options] /@ (orbit + epsilon*IdentityMatrix[4]) ;
	negative = transport[object, energy, delta, {start, stop}, steps, solver, options] /@ (orbit - epsilon*IdentityMatrix[4]) ;
	Transpose[(positive - negative)/(2*epsilon)]
] ;

ClearAll[parameterize] ;
parameterize[object_, energy_, delta_, {start_, stop_}, steps_, orbit_, epsilon_, solver_:radFldPtcTrj, options:OptionsPattern[]] := Block[
	{tm, sm, tmp, tmm, dmdp, S, A, B},
	tm = matrix[object, energy, 0.0, {start, stop}, steps, epsilon, solver, options] ;
	sm = symplectify[tm] ;
	tmp = matrix[object, energy, +delta, {start, stop}, steps, orbit, epsilon, solver, options] ;
	tmm = matrix[object, energy, -delta, {start, stop}, steps, orbit, epsilon, solver, options] ;
	dmdp = (tmp - tmm)/2/delta ;
	S = identity[2] ;
	A = Re[- S . MatrixLog[sm]] ;
	B = - S . MatrixExp[- S . A] . dmdp ;
	{tm, sm, A, B, 1/2 (B + Transpose[B])}
] ;


(* --------- Only Usefull for Mathmatica 2.2 --------- *)

RadUtiMem[]:=(
Unprotect[In,Out,InString];
Clear[In,Out,InString];
Protect[In,Out,InString];);


(* --------- Loading Radia.exe --------- *)

If[$VersionNumber >=3 ,(
$HistoryLength=1;
$RadDir2=ToFileName[{$TopDirectory,"AddOns","Applications","Radia"}];
$RadDir1=ToFileName[{$RadDir2},"Radia.exe"];
)];

If[$VersionNumber <3 ,($RadDir1=StringJoin[$RadDir,"Radia.exe"];)];

If[StringMatchQ[$Version,"Power Macintosh*"]==True,
$RadDir1="'"<>$RadDir1<>"'"];

Off[LinkOpen::linkf,LinkOpen::linke, LinkObject::linkx,Unset::norep,General::spell1];

Uninstall[Radlk];
Radlk = $Failed;
numb=0;
tnumb=20;
Rad::LoadFail="Failed to load Radia.exe";

While[Radlk == $Failed && numb < tnumb,
(Radlk=Install[$RadDir1];numb+=1;Pause[0.8])];

If[Radlk ==$Failed,Message[Rad::LoadFail],
Print["Radia.exe (Re)Loaded at iteration # ",numb],"OK"];

Remove[numb,tnumb,$RadDir2];
(* Remove[$RadDir1]; *)
On[LinkOpen::linkf,LinkObject::linkx,Unset::norep,General::spell1];

radFldLenTol[1. 10^(-9),1. 10^(-9)];


(* --------- Checking Configuration --------- *)

(*
If[StringMatchQ[$Version,"*Power Macintosh*"]
==False && StringMatchQ[$Version,"*Microsoft
 Windows*"]==False  && StringMatchQ[$Version,"*HP-UX
  PA-RISC 3.0*"]==False,Print["This operating system
   is not yet supported",]
];
*)

(*
If[StringMatchQ[$Version,"Power Macintosh 2.0*"]==True 
|| StringMatchQ[$Version,"Power Macintosh 2.1*"]==True 
|| StringMatchQ[$Version,"Microsoft Windows 2*"]==True, 
Print["This version of Mathematica is not supported",]
];
*)

If[StringMatchQ[$Version,"Power Macintosh*"]==True, radUtiIntrptTim[1]];

If[StringMatchQ[$Version,"Microsoft Windows*"]==True, rAdUtiRlxMemAllocMet["tot"]];

RadUtiVer[]:=(
If[radUtiVer[]!= $RadVersion,Print["Wrong Version of Radia.exe"]];
If[radUtiVer[] == $RadVersion,Print["Radia Version: ",$RadVersion," is loaded"]];
)

RadUtiVer[];

Print["Radia is copyright ESRF, France."];
Print["Portions copyright Synchrotron SOLEIL, France."];
Print["Portions copyright Wolfram Research, Inc."];


(* --------- Add things here for testing --------- *)

